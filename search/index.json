[{"content":"As promised on my blog post about the Linux Kernel mentorship program, this article will be about my endeavours in trying to enable turbo support for my laptop on Linux.\nHow it all began It all started one day when I was sitting in front of my laptop completely zoned out. My eyes glanced upon the keyboard and I caught myself staring at a key which usually opens an app to change performance profiles of the laptop.\nNow, much to the surprise of nobody, this key did not do anything on Linux since the NitroSense app (as is the case with most proprietary software) only works on Windows, regardless, I still wondered if it was possible to change thermal profiles on Linux. To my surprise, someone had already made a kernel module for this purpose! Unfortunately (or fortunately, since we wouldn\u0026rsquo;t have this article otherwise :)) it only supported the Acer Predator Series of laptops, whereas my laptop was from the Nitro Series.\nAnyways, it proved as a good starting point and while going through the source code of the project, I realized that this module was nothing more than a modified fork of a module from the platform profile subsystem on the kernel tree.\nLet the tinkering begin! Finding The Hidden Interface After a brief skim through the project, I understood that things like RGB LEDs, fan profiles and certain other hardware related functionalities are often controlled through something known as WMI, during this phase I also chanced upon a youtube miniseries created by the author of the project which gave me some great insight into how this project works under the hood.\nIn short, the WMI interface allows software to communicate with the hardware by sending certain commands. These commands are handled by special WMI entries defined in the ACPI tables stored in the system firmware. That\u0026rsquo;s a whole lot of words just to say â€” system send command, hardware do thing.\nPlaying around with WMI First off I started by randomly tweaking a few values in the source code (sidenote: you probably shouldn\u0026rsquo;t be doing this at the kernel level!) and briefly got my fans to spin to their maximum speeds but the thermal profiles did not seem to budge, my CPU was still throttled at a respectable 3.2 GHz and I was none the wiser\nRegardless, this confirmed my assumptions regarding WMI and thus I booted into Windows to monitor WMI activity and sure enough, whenever I changed thermal profiles using the app, a WMI event was registered on the Windows Event Viewer.\nThe monitor told me that two WMI functions - SetGamingFanBehavior and SetGamingMiscSetting were called for changing fan speeds and applying overclocks respectively. Just knowing this alone wasn\u0026rsquo;t enough though, I also needed to know what inputs are fed into these methods so that they actually do something. The event viewer, sadly, provided no means to track inputs.\nWMI Explorer Initially, I tried to do some trial and error using a tool I discovered called WMI Explorer to manually invoke these functions but it didn\u0026rsquo;t seem to do anything. I later realized that the only way to figure out the required inputs was to reverse engineer the program which calls the function.\nI also made a small documentation patch during this time to mention this neat little tool in the WMI driver development guide.\nReversing the NitroSense app Thus it began, my first foray into reverse engineering a real app. The NitroSense app was written in C# and thus I used dotPeek to decompile it.\nFan Modes Cracked While searching for the input values for the overclock WMI call, I coincidentally chanced upon the function that was responsible for setting the fan modes â€”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static bool set_all_fan_mode(CommonFunction.Fan_Mode_Type mode_index) { ulong intput = 9; switch (mode_index) { case CommonFunction.Fan_Mode_Type.Auto: intput |= 4259840UL; break; case CommonFunction.Fan_Mode_Type.Max: intput |= 8519680UL; break; case CommonFunction.Fan_Mode_Type.Custom: intput |= 12779520UL; break; } return ((int) WMIFunction.SetAcerGamingFanGroupBehavior(intput).GetAwaiter().GetResult() \u0026amp; (int) byte.MaxValue) == 0; } As we can see, input values of the WMI function are readily available here! There are three magic values which correspond to the three different fan modes. Was a bit surprised to the see the typo in the \u0026lsquo;intput\u0026rsquo; variable, kind of refreshing to know that even billion dollar companies have such mistakes in their code lol.\nIn Search Of Overclocks.. The overclock function was sadly not as simple of an egg to crack. I traced through the GUI code for the app and narrowed it down to this particular function -\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static async Task\u0026lt;int\u0026gt; set_operation_mode(int Operation_Mode) { int output = -1; try { NamedPipeClientStream cline_stream = new NamedPipeClientStream(\u0026#34;.\u0026#34;, \u0026#34;PredatorSense_service_namedpipe\u0026#34;, PipeDirection.InOut); cline_stream.Connect(); output = await Task.Run\u0026lt;int\u0026gt;((Func\u0026lt;int\u0026gt;) (() =\u0026gt; { IPCMethods.SendCommandByNamedPipe(cline_stream, 30, (object) (uint) Operation_Mode); cline_stream.WaitForPipeDrain(); byte[] buffer = new byte[9]; cline_stream.Read(buffer, 0, buffer.Length); return BitConverter.ToInt32(buffer, 5); })).ConfigureAwait(false); cline_stream.Close(); return output; } catch (Exception ex) { return output; } } Don\u0026rsquo;t worry if it all looks like gibberish to you, it did to me as well when I first came across it. Since i was wholly unfamiliar with the Windows API, I asked ChatGPT to explain the code to me like a 5 year old. GPT promptly explained that this function was creating something called a \u0026ldquo;Named Pipe\u0026rdquo; which is used for inter-process communication.\nUh oh, this meant that the actual WMI call was was being made by a process on the receiving end of this pipe. Interestingly, I noted that the name of the pipe was \u0026lsquo;PredatorSense_service\u0026rsquo;, suggesting that the recipient process was a service.\nWhile we are here, let me also comment that the Operation_Mode argument of set_operation_mode() took one of three values: 0, 1 or 4. Which makes sense considering that my lapop has three performance modes.\nThe Final Piece Of The Puzzle Sure enough, there was indeed a service in services.msc named Predator Service, the service started a program called Pssvc.exe. This particular program was written in C++, I initially used IDA to disassemble it before realizing that I had pretty much 0 knowledge of assembly ;-;\nThat\u0026rsquo;s when I remembered Ghidra, a reversing tool developed by the NSA, that I had used during a CTF contest that I had played a long time ago. Ghidra tries its best to produce a readable C-like program from the disassembled code.\nAfter some heavy decompiling on the service file using Ghidra I finally found out that the value is read from the named pipe and then used to call a function from a function pointer table as follows:\n1 (*(code *)(\u0026amp;PTR_LAB_140052c90)[uVar14])(puVar5,puVar8,\u0026amp;local_250,\u0026amp;local_244); Here, \u0026amp;PTR_LAB_140052c90 refers to the following function pointer table -\nIf you remember from earlier, a command index of 30 was passed into the named pipe along with the Operation Mode. This index corresponds to the function pointer that I\u0026rsquo;ve highlighted in the image.\nI still needed to know what the arguments are for this function, here is the relevant section of the code which receives the input from the named pipe and calls this function â€”\nYes, it\u0026rsquo;s one hell of a monstrosityâ€”but after staring at it for a long time, I figured out that all it does is pass an array of bytes from the named pipe with their corresponding byte offsets to the function. You can observe this in the last line of code which actually performs the function call, puVar5 is the array of bytes and puVar8 are the byte offsets (I think anyways)\nJackpot Finally, we are ready to analyze the function that makes the WMI call â€”\nThis function dereferences the values from the byte array and performs a bitwise operation (value \u0026lt;\u0026lt; 8 | 0xb;) on them before passing them to the WMI call. Doing this manually on the OperationMode values from earlier, we get the following values for WMI calls:\n1 2 3 4 5 6 7 8 9 //SetGamingMiscSetting Performance: 1035 Default: 267 Quiet: 11 //SetGamingFanBehavior Custom: 12779520 Auto: 4259840 Max: 8519689 Using WMI Explorer to call this function with this values does indeed change performance profiles and fan speeds! All of this reversing had finally paid off! Or so I thought..\nWriting The Patch After all of that workâ€”reverse engineering the NitroSense app and painstakingly obtaining the correct values, I was ready to write my patch. Which is when I discovered that the kernel module, acer-wmi, which adds WMI functionality to Linux for my laptop already had all of the above values defined! ðŸ™ƒ\nNow this truly threw me for a loop, if someone had already taken the time to reverse these values why weren\u0026rsquo;t they working on my laptop? Initially I thought this was because my turbo button was not producing a WMI event when pressed.\nI reached out the maintainers on the platform profile subsystem asking for help and they were more than ready to help. In fact, one of them even offered to write the patch for me! However since my main aim was to learn, I politely refused and he was kind enough to guide me in the right direction.\nFrom there, I learnt about ACPI tables where these WMI functions are defined and the corresponding tools used to read them. After scanning through the ACPI code I realized that the Predator and Nitro series of laptops share the same values for the profiles and that the core issue was that the Predator series supports two additional profiles.\nThe acer_wmi module had the supported_profiles value hardcoded for the Predator. However, it should have been set dynamically, since the hardware had another WMI call (GetGamingMiscSetting) that returns a bitmap indicating the supported performance profiles. This function was simply not being utilised by the current driver.\nHence, my patchset essentially involved adding dynamic support for setting the supported platform profiles and some other miscellaneous improvements to the platform profile handling for acer laptops. After these patches got merged, I could finally set my performance profiles from the sysfs interface at /sys/firmware/acpi/platform_profile!\nWe weren\u0026rsquo;t done yet though. One last issue I was facing is that on Windows, my CPU was able to reach its max thermal limit of 100Â°C when operating in performance mode but on Linux, it was throttling at 92Â°C. I initially tried tweaking CPU frequency scaling drivers and other settings without success. After a lot of trial and error, a maintainer suggested installing thermaldâ€”and that ended up solving the problem!\nConclusion That just about does it, in this rather wordy blog post I\u0026rsquo;ve written down (almost) my complete approach to adding some unsupported functionality for my hardware to the Linux Kernel. Have to say, while it was certainly frustrating at times, it was a great deal of fun. Rarely do you actually get to go down to the basics like ACPI tables or manually juggle bitmasks to solve problems with your laptop. It\u0026rsquo;s hard to explain but there is a sort of raw simplicity operating at such a low level, everything merely does what its meant to do and it does it well. There\u0026rsquo;s no hidden abstractions or sneaky gotcha\u0026rsquo;s that surprise you.\nGoing through this whole process also made me realize that you can literally solve any problem you have with software, as long as you have the grit to stick with it and see it through.\n","date":"2025-07-20T00:00:00Z","image":"https://hrideshmg.com/p/reversing-turbo/cover_hu_64b7f5c44f3852d6.png","permalink":"https://hrideshmg.com/p/reversing-turbo/","title":"The Key That Did Nothing: My Journey Into the Linux Kernel"},{"content":"You ever just sit down after finishing a show, having this indescribable void inside you that you know can\u0026rsquo;t be filled anytime soon? This was me at 2 AM yesterday after finishing Arcane. I can\u0026rsquo;t quite put my finger on what the cause is â€” is it the realization that there aren\u0026rsquo;t any more episodes? or the fact that this world that you grew so connected to has suddenly ceased to exist?\nWhatever it is, that void is still here and maybe that\u0026rsquo;s okay. Some stories don\u0026rsquo;t really end, they just leave a piece behind with you. The last time I felt like this was after finishing the 1995 classic Neon Genesis Evangelion, a show that is still, to this day, very close to my heart. This blog post isn\u0026rsquo;t really meant to be an exhaustive analysis of the show, rather, it\u0026rsquo;s just a personal reflection of some of the elements that I loved about it.\nThe Animation I don\u0026rsquo;t think this is a field which needs much introduction, Arcane has over 16 accolades for animation from various award ceremonies. One thing that really stood out to me in season 2 was the emphasis on the facial expressions of the characters. Paraphrasing a comment I saw on reddit â€” It actually felt like they were acting, 3D models, acting! You can see the pain, hesitation and trauma written all over their faces. Their pupils dilate and their eyes glisten depending on the scenes the characters are in.\nFortiche have pretty much cemented themselves as pioneers with their distinctive style and attention to detail and I\u0026rsquo;m pretty excited to see what comes out of this studio next.\nThe Characters/Writing This is where the brilliance of the show really shines through. I could personally connect and empathize with a lot of characters in the show, their arcs are meaningful and full of emotion. Almost each and every character in the show has flaws in one way or another and they all try to overcome their pain and trauma in distinct ways.\nThere\u0026rsquo;s this rawness to the way the show explores themes like revenge, betrayal, abandonment, family, loss etc. The writers really don\u0026rsquo;t pull their punches here, so don\u0026rsquo;t be surprised if a character you really like ends up in the casket a few episodes down.\nIt also helps that the show religiously follows the rule of 3. Each season is composed of 9 episodes each with every 3 episodes forming an act. Each act moves the story forward in a significant and intentional way. The end result of this is that no episode really feels like filler, because all of them serve a specific purpose in their respective acts. Everything has weight and by the time you reach the end of an act, it feels like you\u0026rsquo;ve completed a movie by itself.\nThe Music/Sound Design Arcane has hands down one of the best sound design I\u0026rsquo;ve seen in any animated show ever, an incredible amount of detail has gone into making sure the world feels real. Every punch, object falling, weapon firing have this impact to them, it almost feels like you are there in the world hearing it for yourself. Do yourself a favour and watch this show with headphones on, trust me, you won\u0026rsquo;t regret it.\nThe soundtrack is also out of this world, the songs really do take impactful scenes to the next level by amplifying the emotions on display in each scene. I read somewhere that each song was custom made for the show and it shows. I\u0026rsquo;ve been replaying \u0026ldquo;Ma Meilleure Ennemie\u0026rdquo; from episode 8 of season 2 nonstop and the way they integrated it with the scene was impeccable.\nIt kind of reminds me of the ending song of Cyberpunk: Edgerunners - \u0026ldquo;I Really Want to Stay at Your House\u0026rdquo;. I\u0026rsquo;d like to keep this review spoiler free but if you know, you know :)\nMusic when done right is actually one of my favourite aspects of media whether it be shows, movies or games for the simple reason that listening to a song can evoke the same emotion that you felt while actually experiencing the story for the first time.\nThe World Building As someone who hasn\u0026rsquo;t really played the game much or has read any of the lore. The writers definitely managed to make the land of Piltover (and Runeterra in general) feel alive. I will always say that first and foremost, Arcane is a show about the characters but they have put a lot of work into the technical aspects as well. (Minor Spoilers!) Even exploring concepts like time travel and parallel dimensions.\nSadly, it did feel a bit rushed at times, particularly during S2, but its understandable considering that they wanted to finish the story in two seasons.\nConclusion I have to say, I do feel a bit spoiled after watching this show. It\u0026rsquo;s not everyday that you come across a piece of art that has had this much love and attention to detail put into it. Don\u0026rsquo;t let the fact that its an animated show put you off, you would be missing out on one of the finest shows produced in this decade (maybe more).\n","date":"2025-03-14T00:00:00Z","image":"https://hrideshmg.com/p/arcane/cover_hu_1f5f9685a1eefa9f.jpg","permalink":"https://hrideshmg.com/p/arcane/","title":"Arcane"},{"content":"This blog post has been long overdue but I\u0026rsquo;ve finally gotten around to it! I graduated from the Linux Kernel Bug Fixing Mentorship Programme'25 sometime in late january. I\u0026rsquo;ll be detailing my experience about the same in this blog post.\nWhat is the LKMP? The Linux Kernel Mentorship programme or LKMP for short is, as written on their website -\n\u0026ldquo;A structured remote learning opportunity for aspiring Linux Kernel developers\u0026rdquo;\nIn specific, the programme that I was part of was the Linux Kernel Bug Fixing Programme but don\u0026rsquo;t let the name fool you, you can do a lot more than just fix bugs, like writing new device drivers or extending existing ones.\nIn short, its an opportunity where beginners to kernel dev can get their feet wet with the Linux Kernel while being supported by experienced mentors. Note that unlike GSoC or traditional LFX mentorships, the kernel bug fixing mentorship is an unpaid one but the knowledge you get from the whole process is worth its weight in gold.\nIf, however, you\u0026rsquo;re someone who needs a little more motivation than that then you should probably look elsewhere as you can only ever do one LFX mentorship during your lifetime. Choose wisely :)\nThe structure of the program I would say that the LKMP is a very flexible program in the sense that there is no roadmap or particular set of tasks that you have to complete in order to graduate. You are free to make any kind of meaningful contribution to the kernel, this opens the door to work on anything that you\u0026rsquo;re truly interested in. This coupled with the fact that you get to attend weekly meetings with experienced kernel developers makes it a very enriching experience.\nThe only requirements for graduation is that you need to have around 5-10 patches accepted into the Linux Kernel by the end of the program. This might seem difficult at the start, but trust me, once you get into the flow of things, it becomes a breeze.\nWhy I decided to join the programme There\u0026rsquo;s actually a bit of an interesting backstory behind this, when I first bought my laptop (an Acer Nitro 5) and installed Linux on it ( as one does with a brand new PC, obviously ) I noticed that no matter what I tried, I just could not get the headphone jack to detect the microphone.\nThis is an issue that I had revisisted multiple times over the course of a year and it had even persisted across distros! This led me to believe that the issue was in the kernel and sure enough, after a bit of research this had been the case.\nAround this time a few of my club seniors suggested me to try out the LFX mentorship since I wanted to explore low level development and I figured that it was the perfect opportunity to try and fix this tiny (but very annoying!) problem. As Plato once said -\n\u0026ldquo;Necessity is the mother of invention\u0026rdquo; \u0026ndash; Plato\nMy contributions Fixing microphone input on the ALC287 Codec After a bit of research, I stumbled upon this excellent blog post by Luke Jones on his adventure for getting sound to work on Asus ROG notebook. If it were not for this resource, this journey would have been much, much longer.\nThrough his blog I understood a lot of fundamentals regarding how audio is handled for Realtek Codecs on Linux but wait a minute Hridesh, what on earth is a Codec? Let me explain it with the help of an image -\nAs you can see the Codec is a hardware chip on the motherboard which is responsible for controlling the speakers and microphone on the system. The kernel interacts with this chip using the I2C interface, but we don\u0026rsquo;t need to go that deep to fix our issue.\nThe problem that occurs here is that this codec expects the software to interact with it in a certain manner. However, Realtek, in all their glory, often ship these chips with non-standard configurations, meaning they don\u0026rsquo;t always properly report their capabilities to the operating system. Instead, they rely on driver-specific quirks to function correctly.\nThe issue is that these quirks are only implemented in the Windows driver, leaving Linux users to manually patch or configure the kernel to get everything working. The result of this? A giant file in the kernel tree named patch_realtek.c which has (at the time of writing) over 13,000 lines of patches for various different codecs.\nAfter digging a bit deeper into it and experimenting a bit, I finally got it to work after reverse engineering the windows driver and figuring out which quirk was missing! This was my reaction after finally see the mic input meter start moving -\nApparently, the quirk that I had found out was already defined in the patch_realtek file, so all I had to do was map it to my codec. I quickly made a patch and submitted it and it finally got released in v6.13 of the kernel. This means that everyone who has my laptop or uses the same audio codec can finally enjoy working microphone input.\nEnabling Turbo support on my laptop The second contribution is the one I spent the most amount of time on and it\u0026rsquo;s where I realized how awesome the kernel community really is. My laptop is a gaming laptop and gaming laptops often have this feature where you can activate certain profiles like \u0026ldquo;performance\u0026rdquo; or \u0026ldquo;quiet\u0026rdquo;.\nThese profiles enable you to extract more power from your machine by overclocking the CPU/GPU or tell it to slow down the fans so that it runs more quietly. However, these profiles are only accessible on Windows through the dedicated vendor app.\nI was initially skeptical as to whether it was even possible to bring this support to Linux, which prompted me to send an email to the kernel mailing list asking for help. The developers there were extremely supportive and they even offered to write the patch for me! However, since I wanted to learn and tinker with it, I endeavoured to try and implement it myself.\nThrough the process, I learnt about a variety of different things like ACPI tables, WMI calls, sysfs interfaces, and even did some indepth reverse-engineering using Ghidra and dotPeek to find out how the Windows app worked underneath the hood. A full technical write up on this would warrant another blog post, so keep an eye out for that The blog post for it is now out :)\nMy experience The LKMP has been one of the most impactful programs that I\u0026rsquo;ve participated in. You might find this surprising, but the majority of kernel developers aren\u0026rsquo;t actually paid for their work, they do everything voluntarily and their enthusiasm is nothing short of infectious.\nTaking part in this whole process really taught me a lot, the kernel community has very high standards when it comes to code quality. I\u0026rsquo;ve had maintainers painstakingly take apart each line in my patch to suggest improvements and question logic but don\u0026rsquo;t be scared of this! In fact, this level of scrutiny is what makes the kernel so robust. Every comment from a maintainer is an opportunity to learn, not just about kernel code but about writing efficient, clean and maintainable code.\nI feel like the way I approach code has fundamentally changed after taking part in the LKMP. For starters, I\u0026rsquo;ve become much more conscious of the changes that I make and running git diff to verify my logic before every commit has pretty much become second nature to me.\nDebugging issues in a codebase as large and complex as the Linux Kernel has also given me the confidence that if I put my mind to it, I can tackle any problem, no matter how large it may seem. It wouldn\u0026rsquo;t be an exaggeration to say that I\u0026rsquo;ve improved significantly as a developer after completing the programme.\nConclusion I think I\u0026rsquo;ll just end this post by saying that if you\u0026rsquo;ve been meaning to explore kernel development or just become a better developer overall, the LKMP is a fantastic opportunity. The learning curve might be a bit steep, but as they say - \u0026ldquo;Its the hard things in life that are worth doing.\u0026rdquo;\nHere is a link where you can check out all of my contributions to the kernel: https://web.git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/log/?qt=author\u0026q=hridesh\n","date":"2025-03-08T00:00:00Z","image":"https://hrideshmg.com/p/lfx-mentorship/cover_hu_d00796e5ce2e85a6.png","permalink":"https://hrideshmg.com/p/lfx-mentorship/","title":"Linux Kernel Mentorship"},{"content":"I sit here in the darkness, my laptop wide open, the gentle hum of the ceiling fan and the rhythmic pulse of the led on the wifi router my only companion.\nThere is no sound, except the one within my mind. Thoughts as they are - floating about, colliding and colluding, such is the nature of existence.\nSound may very well be the antithesis of introspection, for quiet retreat is a tough thing to find in this noisy and bustling world. Yet, I wish it more common.\nThe external silence only serves to amplify the internal chaos; yet, without it, one wouldn\u0026rsquo;t even realize the disarray within.\n","date":"2025-02-16T00:00:00Z","permalink":"https://hrideshmg.com/p/silence/","title":"Silence"},{"content":"A bit about myself Hey there I\u0026rsquo;m Hridesh MG and welcome to my little space on the interwebs. I\u0026rsquo;m a sophomore student pursuing Computer Science Engineering at Amrita University. I\u0026rsquo;ve been meaning to make this blog for a while now but only got around to doing it recently.\nI\u0026rsquo;m quite passionate about software development and actually I\u0026rsquo;m part of an open source club at my college called amFOSS. Tech is not all though, few of my other hobbies include tinkering with electronics, watching anime, playing video games, and pondering about life while gazing at the stars. That said, I\u0026rsquo;m always open to trying new things and I always like to refer to myself as a generalist, as the famous quote goes -\nJack of all trades, master of none, though often better than a master of one\nWhat you can expect There\u0026rsquo;s no point in hiding it, as you could probably tell from my hobbies, I\u0026rsquo;m a huge nerd and that is going to reflect on the type of content I write as well :)\nHere are a few topics that you can expect to (hopefully) find on this blog soon -\nTechnical blogs about stuff I\u0026rsquo;ve learned recently or things I find interesting. Reviews on Anime I\u0026rsquo;ve watched or Games I\u0026rsquo;ve played. Tutorials on random things that I feel deserve one. Sharing my experience on events I\u0026rsquo;ve attended/helped organize. Random jottings about life. ","date":"2025-02-13T00:00:00Z","image":"https://hrideshmg.com/p/hello-world/cover_hu_a9f63b553fd3ecb0.webp","permalink":"https://hrideshmg.com/p/hello-world/","title":"Hello World!"}]